<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0060)http://www.cs.unc.edu/~mcmillan/comp136/Lecture7/circle.html -->
<HTML><HEAD><TITLE>Comp 136 -- Circle-Drawing Algorithms</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY bgColor=#c0c0c0>
<H1>Circle-Drawing Algorithms</H1>
<HR>
Beginning with the equation of a circle:<BR>
<CENTER><IMG height=35 
src="Comp 136 -- Circle-Drawing Algorithms_files/circleEqn1.gif" width=265 
border=0> </CENTER>We could solve for y in terms of x<BR>
<CENTER><IMG height=52 
src="Comp 136 -- Circle-Drawing Algorithms_files/circleEqn2.gif" width=266 
border=0>, </CENTER>and use this equation to compute the pixels of the circle. 
When finished we'd end up with code that looked something like the following: <PRE>    public void circleSimple(int xCenter, int yCenter, int radius, Color c)
    {
        int pix = c.getRGB();
        int x, y, r2;
        
        r2 = radius * radius;
        for (x = -radius; x &lt;= radius; x++) {
            y = (int) (Math.sqrt(r2 - x*x) + 0.5);
            raster.setPixel(pix, xCenter + x, yCenter + y);
            raster.setPixel(pix, xCenter + x, yCenter - y);
        }
    }
</PRE>And it would result in circles that look like:<BR>
<CENTER><APPLET height=301 width=301 code=Circles.class><PARAM NAME="algorithm" VALUE="Simple"><PARAM NAME="height" VALUE="301"><PARAM NAME="width" VALUE="301"><PARAM NAME="code" VALUE="Circles.class"><PARAM NAME="codeBase" VALUE="http://www.cs.unc.edu/~mcmillan/comp136/Lecture7/"></APPLET> 
</CENTER>
<BLOCKQUOTE><FONT size=-1>The above applet demonstrates the 
  <I>circleSimple()</I> algorithm. Click and drag the left button to specify the 
  circle's center and a point on its radius. Selecting the right button will 
  clear the drawing. The circle approximation generated by the algorithm is 
  overlaid with an ideal circle for comparison. </FONT></BLOCKQUOTE>
<P>As you can see the circles look fine in areas where only one pixel is 
required for each column, but in areas of the circle where the local slope is 
greater the one the circle appears discontinuous (where have we seen this 
before?). 
<P>We could take the approach of computing the derivative (i.e. the local slope) 
of the function at each point and then make a decision whether to step in the x 
direction or the y direction. But, we will explore a different tact here. 
<P>A circle exhibits a great deal of symmetry. We've already exploited this 
somewhat by plotting two pixels for each function evaluation; one for each 
possible sign of the square-root function. This symmetry was about the x-axis. 
The reason that a square-root function brings out this symmetry results from our 
predilection that the x-axis should be used as an independent variable in 
function evaluations while the y-axis is dependent. Thus, since a function can 
yield only one value for member of the domain, we are forced to make a choice 
between positive and negative square-roots. The net result is that our simple 
circle-drawing algorithm exploits <I>2-way symmetry</I> about the x-axis. 
<P>Obviously, a circle has a great deal more symmetry. Just as every point above 
an x-axis drawn through a circle's center has a symmetric point an equal 
distance from, but on the other side of the x-axis, each point also has a 
symmetric point on the opposite side of a y-axis drawn through the circle's 
center. 
<CENTER><IMG height=271 
src="Comp 136 -- Circle-Drawing Algorithms_files/symmetry4.gif" width=270 
border=0></CENTER>We can quickly modify our previous algorithm to take advantage 
of this fact as shown below. <PRE>    public void circleSym4(int xCenter, int yCenter, int radius, Color c)
    {
        int pix = c.getRGB();
        int x, y, r2;
        
        r2 = radius * radius;
        raster.setPixel(pix, xCenter, yCenter + radius);
        raster.setPixel(pix, xCenter, yCenter - radius);
        for (x = 1; x &lt;= radius; x++) {
            y = (int) (Math.sqrt(r2 - x*x) + 0.5);
            raster.setPixel(pix, xCenter + x, yCenter + y);
            raster.setPixel(pix, xCenter + x, yCenter - y);
            raster.setPixel(pix, xCenter - x, yCenter + y);
            raster.setPixel(pix, xCenter - x, yCenter - y);
        }
    }
</PRE>This circle-drawing algorithm uses <I>4-way symmetry</I>. 
<CENTER><APPLET height=301 width=301 code=Circles.class><PARAM NAME="algorithm" VALUE="Symmetry4"><PARAM NAME="height" VALUE="301"><PARAM NAME="width" VALUE="301"><PARAM NAME="code" VALUE="Circles.class"><PARAM NAME="codeBase" VALUE="http://www.cs.unc.edu/~mcmillan/comp136/Lecture7/"></APPLET> 
</CENTER>
<BLOCKQUOTE><FONT size=-1>The above applet demonstrates the 
  <I>circleSym4()</I> algorithm. Click and drag the left button to specify the 
  circle's center and a point on its radius. Selecting the right button will 
  clear the drawing. The circle approximation generated by the algorithm is 
  overlaid with an ideal circle for comparison. </FONT></BLOCKQUOTE>
<P>This algorithm <B>has all the problems</B> of our previous algorithm, but, it 
gives the same result with <B>half as many function evaluations</B>. So much for 
"making it work first" before optimizing. But, we're on a roll so let's push 
this symmetry thing as far as it will take us. 
<P>Notice also that a circle exhibits symmetry about the pair of lines with 
slopes of one and minus one, as shown below. 
<CENTER><IMG height=271 
src="Comp 136 -- Circle-Drawing Algorithms_files/symmetry8.gif" width=270 
border=0></CENTER>We can find any point's symmetric complement about these lines 
by permuting the indices. For example the point <I>(x,y)</I> has a complementary 
point <I>(y,x)</I> about the line<I>x=y</I>. And the total set of complements 
for the point (x,y) are<BR>
<UL>
  <UL><I>{(x,-y), (-x,y), (-x,-y), (y,x), (y,-x), (-y,x),(-y,-x)}</I> </UL></UL>
<P>The following routine takes advantage of this <B>8-way symmetry</B>. <PRE>    public void circleSym8(int xCenter, int yCenter, int radius, Color c)
    {
        int pix = c.getRGB();
        int x, y, r2;

        r2 = radius * radius;
        raster.setPixel(pix, xCenter, yCenter + radius);
        raster.setPixel(pix, xCenter, yCenter - radius);
        raster.setPixel(pix, xCenter + radius, yCenter);
        raster.setPixel(pix, xCenter - radius, yCenter);

        y = radius;
        x = 1;
        y = (int) (Math.sqrt(r2 - 1) + 0.5);
        while (x &lt; y) {
            raster.setPixel(pix, xCenter + x, yCenter + y);
            raster.setPixel(pix, xCenter + x, yCenter - y);
            raster.setPixel(pix, xCenter - x, yCenter + y);
            raster.setPixel(pix, xCenter - x, yCenter - y);
            raster.setPixel(pix, xCenter + y, yCenter + x);
            raster.setPixel(pix, xCenter + y, yCenter - x);
            raster.setPixel(pix, xCenter - y, yCenter + x);
            raster.setPixel(pix, xCenter - y, yCenter - x);
            x += 1;
            y = (int) (Math.sqrt(r2 - x*x) + 0.5);
        }
        if (x == y) {
            raster.setPixel(pix, xCenter + x, yCenter + y);
            raster.setPixel(pix, xCenter + x, yCenter - y);
            raster.setPixel(pix, xCenter - x, yCenter + y);
            raster.setPixel(pix, xCenter - x, yCenter - y);
        }
    }
</PRE>So now we get 8 points for every function evaluation, and this routine 
should be approximately 4-times faster than our initial circle-drawing 
algorithm. What's going on with the four pixels that are set outside the loop 
(both at the top and bottom)? Didn't I say that every point determines 7 others? 

<CENTER><APPLET height=301 width=301 code=Circles.class><PARAM NAME="algorithm" VALUE="Symmetry8"><PARAM NAME="height" VALUE="301"><PARAM NAME="width" VALUE="301"><PARAM NAME="code" VALUE="Circles.class"><PARAM NAME="codeBase" VALUE="http://www.cs.unc.edu/~mcmillan/comp136/Lecture7/"></APPLET> 
</CENTER>
<BLOCKQUOTE><FONT size=-1>The above applet demonstrates the 
  <I>circleSym4()</I> algorithm. Click and drag the left button to specify the 
  circle's center and a point on its radius. Selecting the right button will 
  clear the drawing. The circle approximation generated by the algorithm is 
  overlaid with an ideal circle for comparison. </FONT></BLOCKQUOTE>
<CENTER><FONT size=+3>Wait a Minute!<BR>What has happened here?</FONT></CENTER>
<P>It seems suddenly that our circle's appear continuous, and we added no 
special code to test for the slope. Symmetry has come to our rescue (actually, 
symmetry is also what saved us on lines... think about it). 
<HR>

<P>So our next objective is to simplify the function evaluation that takes place 
on each iteration of our circle-drawing algorithm. All those multiplies and 
square-root evaluations are expensive. We can do better. 
<P>One approach is to manipulate of circle equation slightly. First, we 
translate our coordinate system so that the circle's center is at the origin 
(the book leaves out this step), giving: 
<CENTER><IMG height=59 
src="Comp 136 -- Circle-Drawing Algorithms_files/translate.gif" width=591 
border=0></CENTER>Next, we simplify and make the equation homogeneous (i.e. 
independent of a scaling of the independent variables; making the whole equation 
equal to zero will accomplish this) by subtracting r<SUP>2</SUP> from both 
sides. 
<CENTER><IMG height=54 
src="Comp 136 -- Circle-Drawing Algorithms_files/simplifyEqn.gif" width=251 
border=0></CENTER>We can regard this expression as a function in x and y. 
<CENTER><IMG height=58 
src="Comp 136 -- Circle-Drawing Algorithms_files/decrimEqn.gif" width=345 
border=0></CENTER>Functions of this sort are called <I>discriminating 
functions</I> in computer graphics. They have the property of partitioning the 
domain, pixel coordinates in our case, into one of three categories. When 
<I>f(x,y)</I> is equal to zero the point lies on the desired locus (a circle in 
this case), when <I>f(x, y)</I> evaluates to a positive result the point lies 
one one side of the locus, and when <I>f(x,y)</I> evaluates to negative negative 
it lies on the other side. 
<CENTER><IMG height=200 
src="Comp 136 -- Circle-Drawing Algorithms_files/regions.gif" width=200 
border=0></CENTER>
<P>What we'd like to do is to use this discriminating function to maintain our 
trajectory of drawn pixels as close as possible to the desired circle. Luckily, 
we can start with a point on the circle, <I>(x<SUB>0</SUB>, y<SUB>0</SUB>+r)</I> 
(or (<I>0, r)</I> in our adjusted coordinate system). As we move along in steps 
of x we note that the slope is less than zero and greater than negative one at 
points in the direction we're heading that are near our known point on a circle. 
Thus we need only to figure out at each step whether to step down in y or 
maintain y at each step. 
<CENTER><IMG height=271 
src="Comp 136 -- Circle-Drawing Algorithms_files/slopeAtTop.gif" width=270 
border=0> </CENTER>We will proceed in our circle drawing by literally "walking a 
tight rope". When we find ourselves on the negative side of the discriminating 
function, we know that we are slightly inside of our circle so our best hope of 
finding a point on the circle is to continue with y at the same level. If we 
ever find ourselves outside of the circle (indicated by a positive discriminate) 
we will decrease our y value in an effort to find a point on the circle. Our 
strategy is simple. We need only determine a way of computing the next value of 
the discriminating function at each step. 
<P>Consider what the next value of the discriminating function is in the case 
that there is no change in y. 
<CENTER><IMG height=41 
src="Comp 136 -- Circle-Drawing Algorithms_files/sameYdesc.gif" width=354 
border=0></CENTER>We can find an incremental method for computing this equation 
by expanding terms and substituting for <I>x<SUP>2</SUP> + y<SUP>2</SUP> - 
r<SUP>2</SUP></I>, giving: 
<CENTER><IMG height=47 
src="Comp 136 -- Circle-Drawing Algorithms_files/ifNegEqn.gif" width=338 
border=0></CENTER>
<P>Thus when we are inside the circle with a negative discriminant we can 
incrementally update the discriminant's value by incrementing by <I>2x + 1</I>. 
<P>Suppose instead that we find ourselves outside of the circle, in this case 
the next value of the descriminant should be: 
<CENTER><IMG height=44 
src="Comp 136 -- Circle-Drawing Algorithms_files/nextYdesc.gif" width=450 
border=0></CENTER>Again we can expand and substitute to arrive at the following 
incremental update equation which will be used when we find ourselves outside 
the circle: 
<CENTER><IMG height=44 
src="Comp 136 -- Circle-Drawing Algorithms_files/ifPosEqn.gif" width=446 
border=0></CENTER>So when we are outside of the circle we must turn back towards 
it by changing the <I>y</I> value to <I>y - 1</I>. Then we must update the 
discriminate by <I>2x - 2y + 2</I>. 
<P>All that remains is to compute the initial value for our discriminating 
function. Our initial point, <I>(0,r)</I>, was on the circle. The very next 
point, <I>(1, r)</I>, will be outside if we continue without changing <I>y</I> 
(why?). However, we'd like to adjust our equation so that we don't make a change 
in y unless we are more than half way to it's next value. This can be 
accomplished by initialing the discriminating function to the value at <I>y - 
1/2</I>, a point slightly inside of the circle. This is similar to the initial 
offset that we added to the DDA line to avoid rounding at every step. 
<CENTER><IMG height=38 
src="Comp 136 -- Circle-Drawing Algorithms_files/initialDesc.gif" width=453 
border=0></CENTER>Initializing this discriminator to the <I>midpoint </I>between 
the current <I>y</I> value and the next desired value is where the algorithm 
gets its name. In the following code the symmetric plotting of points has be 
separated from the algorithm. <PRE>    private final void circlePoints(int cx, int cy, int x, int y, int pix)
    {
        int act = Color.red.getRGB();
        
        if (x == 0) {
            raster.setPixel(act, cx, cy + y);
            raster.setPixel(pix, cx, cy - y);
            raster.setPixel(pix, cx + y, cy);
            raster.setPixel(pix, cx - y, cy);
        } else 
        if (x == y) {
            raster.setPixel(act, cx + x, cy + y);
            raster.setPixel(pix, cx - x, cy + y);
            raster.setPixel(pix, cx + x, cy - y);
            raster.setPixel(pix, cx - x, cy - y);
        } else 
        if (x &lt; y) {
            raster.setPixel(act, cx + x, cy + y);
            raster.setPixel(pix, cx - x, cy + y);
            raster.setPixel(pix, cx + x, cy - y);
            raster.setPixel(pix, cx - x, cy - y);
            raster.setPixel(pix, cx + y, cy + x);
            raster.setPixel(pix, cx - y, cy + x);
            raster.setPixel(pix, cx + y, cy - x);
            raster.setPixel(pix, cx - y, cy - x);
        }
    }

    public void circleMidpoint(int xCenter, int yCenter, int radius, Color c)
    {
        int pix = c.getRGB();
        int x = 0;
        int y = radius;
        int p = (5 - radius*4)/4;

        circlePoints(xCenter, yCenter, x, y, pix);
        while (x &lt; y) {
            x++;
            if (p &lt; 0) {
                p += 2*x+1;
            } else {
                y--;
                p += 2*(x-y)+1;
            }
            circlePoints(xCenter, yCenter, x, y, pix);
        }
    }
</PRE>
<CENTER><APPLET height=301 width=301 code=Circles.class><PARAM NAME="algorithm" VALUE="Midpoint"><PARAM NAME="height" VALUE="301"><PARAM NAME="width" VALUE="301"><PARAM NAME="code" VALUE="Circles.class"><PARAM NAME="codeBase" VALUE="http://www.cs.unc.edu/~mcmillan/comp136/Lecture7/"></APPLET> 
</CENTER>
<HR>
<I>The page last updated Tuesday, September 17, 1996</I> </BODY></HTML>
